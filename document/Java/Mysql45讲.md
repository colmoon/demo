### 01 基础架构

![image-20220807083242966](D:\Documents\anhen\typora\Mysql45讲.assets\image-20220807083242966.png)

查询缓存功能基本不用，Mysql8.0已经没有此功能。

分析器先做词法分析，再做语法分析。



### 02 日志系统

redo log（重做日志），binlog（归档日志）。

这两种日志有以下三点不同。 

1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。 
2.  redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的 是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。 
3.  redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件 写到一定大小后会切换到下一个，并不会覆盖以前的日志。

![image-20220807084111298](D:\Documents\anhen\typora\Mysql45讲.assets\image-20220807084111298.png)

可以看到，InnoDB在写redo log时，并不是一次性写完的，而有两个阶段，Prepare与Commit阶段，这就是"两阶段提交"的含义。

binlog并不具备crash-safe的能力，需要redo log来实现crash-safe能力。



### 03 事务隔离

隔离级别：

读未提交（read uncommitted）、 读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。

1. 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。 

2. 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 

3. 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一 致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 

4. 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突 的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。



### 04 深入浅出索引（上）

InnoDB采用的B+树结构，以及为什么 InnoDB要这么选择。B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。



### 05 深入浅出索引（下）

回到主键索引树搜索的过程，我们称为回表。

覆盖索引 

如果执行的语句是select ID fromTwhere k between 3 and 5，这时只需要查ID的值，而ID的值 已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面， 索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用 的性能优化手段。

在建立联合索引的时候，如何安排索 引内的字段顺序。 这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联 合索引后，一般就不需要单独在a上建立索引了。因此，第一原则是，如果通过调整顺序，可 以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

### 06全局锁和表锁

#### 全局锁

就是对整个数据库实例加锁。

典型使用场景，做全局逻辑备份。

#### 表级锁

Mysql里面的表级锁分为两种：一种是表锁，一种是元数据锁（meta data lock, MDL）。

表锁的语法是lock table ...read/write

另一类表级的锁是MDL。MDL不需要显式调用，在访问一个表的时候会被自动加上。分为MDL读锁，MDL写锁。



### 07 行锁功过

如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放。但是，调整语句顺序并不能完全避免死锁。所以我们引入了死锁和死锁检测的概念，以及提供了三个方案，来减少死锁对数据库的影响。减少死锁的主要方向，就是控制访问相同资源的并发事务量。



### 08 事务到底是隔离的还是不隔离的

InnoDB的行数据有多个版本，每个数据版本有自己的rowtrx_id，每个事务或者语句有自己的一 致性视图。普通查询语句是一致性读，一致性读会根据rowtrx_id和一致性视图确定数据版本的 可见性。

1. 对于可重复读，查询只承认在事务启动前就已经提交完成的数据； 更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）
2. 对于读提交，查询只承认在语句启动前就已经提交完成的数据； 而当前读，总是读取已经提交完成的最新版本。



### 09 普通索引和唯一索引

普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上 是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。 如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer。而在 其他情况下，change buffer都能提升更新性能。



### 10 mysql 为什么有时候会选错索引

索引统计的更新机制，并提到了优化器存在选错索引的可能性。 对于由于索引统计信息不准确导致的问题，你可以用analyze table来解决。 而对于其他优化器误判的情况，你可以在应用端用force index来强行指定索引，也可以通过修改 语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。



### 11 怎么给字符串增加索引

在今天这篇文章中，我跟你聊了聊字符串字段创建索引的场景。我们来回顾一下，你可以使用的 方式有： 

1. 直接创建完整索引，这样可能比较占用空间； 
2. 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；
3.  倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题； 
4.  创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支 持范围扫描。